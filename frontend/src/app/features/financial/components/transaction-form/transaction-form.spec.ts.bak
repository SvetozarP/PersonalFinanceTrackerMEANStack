import { ComponentFixture, TestBed } from '@angular/core/testing';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { RouterTestingModule } from '@angular/router/testing';
import { ReactiveFormsModule } from '@angular/forms';
import { of, throwError } from 'rxjs';
import { ActivatedRoute } from '@angular/router';

import { TransactionFormComponent } from './transaction-form';
import { TransactionService } from '../../../../core/services/transaction.service';
import { CategoryService } from '../../../../core/services/category.service';
import { Transaction, TransactionType, TransactionStatus, PaymentMethod, RecurrencePattern } from '../../../../core/models/financial.model';

describe('TransactionFormComponent', () => {
  let component: TransactionFormComponent;
  let fixture: ComponentFixture<TransactionFormComponent>;
  let transactionService: jasmine.SpyObj<TransactionService>;
  let categoryService: jasmine.SpyObj<CategoryService>;

  const mockTransaction: Transaction = {
    _id: '1',
    title: 'Test Transaction',
    description: 'Test Description',
    amount: 100,
    currency: 'USD',
    type: TransactionType.EXPENSE,
    status: TransactionStatus.COMPLETED,
    categoryId: 'cat1',
    tags: ['test'],
    date: new Date(),
    timezone: 'UTC',
    paymentMethod: PaymentMethod.CASH,
    isRecurring: false,
    recurrencePattern: RecurrencePattern.NONE,
    attachments: [],
    source: 'manual',
    userId: 'user1',
    accountId: 'account1',
    createdAt: new Date(),
    updatedAt: new Date(),
    isDeleted: false
  };

  const mockCategory = {
    _id: 'cat1',
    name: 'Test Category',
    description: 'Test Description',
    color: '#FF0000',
    icon: 'test-icon',
    path: ['Test Category'],
    level: 1,
    isActive: true,
    isSystem: false,
    userId: 'user1',
    createdAt: new Date(),
    updatedAt: new Date()
  };

  beforeEach(async () => {
    const transactionServiceSpy = jasmine.createSpyObj('TransactionService', [
      'getTransactionById', 'createTransaction', 'updateTransaction'
    ]);
    const categoryServiceSpy = jasmine.createSpyObj('CategoryService', [
      'getUserCategories'
    ]);

    // Setup default return values
    transactionServiceSpy.getTransactionById.and.returnValue(of(mockTransaction));
    transactionServiceSpy.createTransaction.and.returnValue(of(mockTransaction));
    transactionServiceSpy.updateTransaction.and.returnValue(of(mockTransaction));
    categoryServiceSpy.getUserCategories.and.returnValue(of([mockCategory]));

    // Mock ActivatedRoute
    const mockActivatedRoute = {
      params: of({ id: 'new' }) // Default to new transaction
    };

    await TestBed.configureTestingModule({
      imports: [
        TransactionFormComponent,
        ReactiveFormsModule,
        RouterTestingModule,
        NoopAnimationsModule
      ],
      providers: [
        { provide: TransactionService, useValue: transactionServiceSpy },
        { provide: CategoryService, useValue: categoryServiceSpy },
        { provide: ActivatedRoute, useValue: mockActivatedRoute }
      ]
    })
    .compileComponents();

    transactionService = TestBed.inject(TransactionService) as jasmine.SpyObj<TransactionService>;
    categoryService = TestBed.inject(CategoryService) as jasmine.SpyObj<CategoryService>;

    fixture = TestBed.createComponent(TransactionFormComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should initialize with default values', () => {
    expect(component.isEditMode).toBe(false);
    expect(component.isSubmitting).toBe(false);
    expect(component.error).toBe(null);
    expect(component.transactionForm).toBeDefined();
  });

  it('should load categories on init', () => {
    expect(categoryService.getUserCategories).toHaveBeenCalled();
  });

  it('should create form with correct structure', () => {
    const form = component.transactionForm;
    expect(form.get('title')).toBeTruthy();
    expect(form.get('description')).toBeTruthy();
    expect(form.get('amount')).toBeTruthy();
    expect(form.get('currency')).toBeTruthy();
    expect(form.get('type')).toBeTruthy();
    expect(form.get('status')).toBeTruthy();
    expect(form.get('categoryId')).toBeTruthy();
    expect(form.get('date')).toBeTruthy();
    expect(form.get('paymentMethod')).toBeTruthy();
    expect(form.get('isRecurring')).toBeTruthy();
  });

  it('should have default form values', () => {
    const form = component.transactionForm;
    expect(form.get('currency')?.value).toBe('USD');
    expect(form.get('type')?.value).toBe(TransactionType.EXPENSE);
    expect(form.get('status')?.value).toBe(TransactionStatus.COMPLETED);
    expect(form.get('isRecurring')?.value).toBe(false);
  });

  it('should populate form when editing', () => {
    // Test form population directly
    component['populateForm'](mockTransaction);
    
    const form = component.transactionForm;
    expect(form.get('title')?.value).toBe('Test Transaction');
    expect(form.get('description')?.value).toBe('Test Description');
    expect(form.get('amount')?.value).toBe(100);
    expect(form.get('currency')?.value).toBe('USD');
    expect(form.get('type')?.value).toBe(TransactionType.EXPENSE);
    expect(form.get('status')?.value).toBe(TransactionStatus.COMPLETED);
    expect(form.get('categoryId')?.value).toBe('cat1');
  });

  it('should handle form submission for new transaction', () => {
    component.transactionForm.patchValue({
      title: 'New Transaction',
      description: 'New Description',
      amount: 50,
      currency: 'USD',
      type: TransactionType.INCOME,
      status: TransactionStatus.COMPLETED,
      categoryId: 'cat1',
      date: '2024-01-15',
      paymentMethod: PaymentMethod.CASH,
      isRecurring: false
    });

    component.onSubmit();

    expect(transactionService.createTransaction).toHaveBeenCalled();
  });

  it('should handle form submission for existing transaction', () => {
    // Set up edit mode manually
    component.transactionId = '1';
    component.isEditMode = true;
    
    component.transactionForm.patchValue({
      title: 'Updated Transaction',
      description: 'Updated Description',
      amount: 75,
      currency: 'USD',
      type: TransactionType.EXPENSE,
      status: TransactionStatus.COMPLETED,
      categoryId: 'cat1',
      date: '2024-01-15',
      paymentMethod: PaymentMethod.CASH,
      isRecurring: false
    });

    component.onSubmit();

    expect(transactionService.updateTransaction).toHaveBeenCalledWith('1', jasmine.any(Object));
  });

  it('should handle form submission errors', () => {
    transactionService.createTransaction.and.returnValue(throwError(() => new Error('API Error')));
    
    // Set up a valid form first
    component.transactionForm.patchValue({
      title: 'Test Transaction',
      description: 'Test Description',
      amount: 100,
      currency: 'USD',
      type: TransactionType.EXPENSE,
      status: TransactionStatus.COMPLETED,
      categoryId: 'cat1',
      date: '2024-01-15',
      paymentMethod: PaymentMethod.CASH,
      isRecurring: false
    });
    
    component.onSubmit();
    
    expect(component.error).toBe('Failed to save transaction');
  });

  it('should handle form validation', () => {
    const form = component.transactionForm;
    
    // Test required field validation
    form.get('title')?.setValue('');
    form.get('title')?.markAsTouched();
    
    expect(form.get('title')?.hasError('required')).toBe(true);
    expect(form.valid).toBe(false);
  });

  it('should handle amount validation', () => {
    const form = component.transactionForm;
    
    // Test minimum amount validation
    form.get('amount')?.setValue(0);
    form.get('amount')?.markAsTouched();
    
    expect(form.get('amount')?.hasError('min')).toBe(true);
    expect(form.valid).toBe(false);
  });

  it('should handle transaction type changes', () => {
    component.transactionForm.get('type')?.setValue(TransactionType.INCOME);
    fixture.detectChanges();
    
    expect(component.transactionForm.get('type')?.value).toBe(TransactionType.INCOME);
  });

  it('should handle recurring transaction toggle', () => {
    component.transactionForm.get('isRecurring')?.setValue(true);
    fixture.detectChanges();
    
    expect(component.transactionForm.get('isRecurring')?.value).toBe(true);
  });

  it('should handle category selection', () => {
    component.transactionForm.get('categoryId')?.setValue('cat1');
    fixture.detectChanges();
    
    expect(component.transactionForm.get('categoryId')?.value).toBe('cat1');
  });

  it('should handle payment method selection', () => {
    component.transactionForm.get('paymentMethod')?.setValue(PaymentMethod.CREDIT_CARD);
    fixture.detectChanges();
    
    expect(component.transactionForm.get('paymentMethod')?.value).toBe(PaymentMethod.CREDIT_CARD);
  });

  it('should handle date changes', () => {
    const testDate = '2024-01-15';
    component.transactionForm.get('date')?.setValue(testDate);
    fixture.detectChanges();
    
    expect(component.transactionForm.get('date')?.value).toBe(testDate);
  });

  it('should have transaction types available', () => {
    expect(component.transactionTypes).toEqual(Object.values(TransactionType));
  });

  it('should have transaction statuses available', () => {
    expect(component.transactionStatuses).toEqual(Object.values(TransactionStatus));
  });

  it('should have payment methods available', () => {
    expect(component.paymentMethods).toEqual(Object.values(PaymentMethod));
  });

  it('should have recurrence patterns available', () => {
    expect(component.recurrencePatterns).toEqual(Object.values(RecurrencePattern));
  });

  it('should handle tags input', () => {
    component.transactionForm.get('tags')?.setValue('tag1,tag2,tag3');
    fixture.detectChanges();
    
    expect(component.transactionForm.get('tags')?.value).toBe('tag1,tag2,tag3');
  });

  it('should handle notes input', () => {
    const notes = 'These are some test notes';
    component.transactionForm.get('notes')?.setValue(notes);
    fixture.detectChanges();
    
    expect(component.transactionForm.get('notes')?.value).toBe(notes);
  });
});
